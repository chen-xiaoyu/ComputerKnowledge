新生代收集器：
Serial 收集器：单线程、复制算法，与 Serial old 配合使用；
ParNew 收集器：Serial 收集器的多线程版本；
Parallel Scavenge 收集器：关注吞吐量（运行用户代码时间/（运行用户代码时间+垃圾收集时间））的收集器，多线程、复制算法；

老年代收集器：
Serial Old 收集器：Serial 收集器的老年代版本，单线程、标记-整理算法；
Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本，多线程、标记-整理算法；

CMS 收集器：
关注最短停顿时间为目标的收集器，注重服务响应速度，更好的用户体验。使用“标记-清除”算法。
分为 4 个步骤 ：初始标记、并发标记、重新标记、并发清除。
其中 初始标记、重新标记仍需要“Stop The World”，耗时长的并发标记和并发清除是可以与用户线程一起工作。
优点：并发收集、低停顿
缺点：
1）CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
2）CMS 收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致 Full GC 产生。
浮动垃圾：由于 CMS 并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 中再清理。这些垃圾就是“浮动垃圾”。
3）CMS 是一款“标记--清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。

G1 收集器：
G1 是一款面向服务端应用的垃圾收集器。
G1 具备如下特点：
1）并行于并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
2）分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次 GC 的旧对象以获取更好的收集效果。
3）空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
4）可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

PS：G1 收集器能够简历可预测的停顿时间模型的原因：
使用 G1 收集器时，它将 JAVA 堆分为多个大小相等的独立空间（Region），G1 跟踪哥哥 Region 里面的垃圾堆积的价值大小（回收所获得空间大小及回收所需时间的经验值），在后台维护与各优先列表，每次根据允许的手机时间，优先回收价值最大的 Region。

G1 运作步骤：
1、初始标记；2、并发标记；3、最终标记；4、筛选回收

上面几个步骤的运作过程和 CMS 有很多相似之处。初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 的值，让下一个阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remenbered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。
