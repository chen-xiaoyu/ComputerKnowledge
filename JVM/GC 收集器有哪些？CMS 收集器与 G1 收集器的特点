新生代收集器：
Serial 收集器：单线程、复制算法，与 Serial old 配合使用；
ParNew 收集器：Serial 收集器的多线程版本；
Parallel Scavenge 收集器：关注吞吐量（运行用户代码时间/（运行用户代码时间+垃圾收集时间））的收集器，多线程、复制算法；

老年代收集器：
Serial Old 收集器：Serial 收集器的老年代版本，单线程、标记-整理算法；
Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本，多线程、标记-整理算法；

CMS 收集器：
关注最短停顿时间为目标的收集器，注重服务响应速度，更好的用户体验。使用“标记-清除”算法。
分为 4 个步骤 ：初始标记、并发标记、重新标记、并发清除。
其中 初始标记、重新标记仍需要“Stop The World”，耗时长的并发标记和并发清除是可以与用户线程一起工作。
优点：并发收集、低停顿
缺点：
1）CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
2）CMS 收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致 Full GC 产生。
浮动垃圾：由于 CMS 并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 中再清理。这些垃圾就是“浮动垃圾”。
3）CMS 是一款“标记--清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。

G1 收集器：
G1 是一款面向服务端应用的垃圾收集器。
G1 具备如下特点：
1）并行于并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
2）分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次 GC 的旧对象以获取更好的收集效果。
3）空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
4）可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。
