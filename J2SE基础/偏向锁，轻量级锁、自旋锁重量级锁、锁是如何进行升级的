偏向锁：
偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，既然是单线程，那就没必要加锁了。
不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用 CAS 机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为有人在执行了，并且线程的 ID 是自己，那么它就直接进入这个方法执行，啥也不用做。

轻量级锁：
轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要做一个标记就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用 CAS 机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了没有人在执行了。

自旋锁：
我们知道，线程从运行态进入阻塞态这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做空循环，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。至于是循环等待几次，这个是可以人为指定一个数字的。

重量级锁
双重检查类似，全部加进来加锁：
我们知道，我们要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。


锁的升级：
偏向锁—>轻量级锁
如果出现其他线程访问该方法这种情况，其他线程一看这个方法的 ID 不是自己，这个时候说明，至少有两个线程要来执行这个方法了，这意味着偏向锁已经不适用了，这个时候就会从偏向锁升级为轻量级锁。

轻量级锁—>自旋锁
当一个线程来执行一个方法的时候，方法里面已经有人在执行了。此时便是遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为自旋锁了。

自旋锁—>重量级锁
如果空循环一定的次数还拿不到锁，那么它就会进入阻塞的状态，即升级为重量级锁。
